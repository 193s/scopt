{"name":"Scopt","body":"scopt\r\n=====\r\n\r\nscopt is a little command line options parsing library.\r\n\r\nIts based on the code from Tim Perrett which his based on Aaron Harnly's code\r\nmentioned [in this thread](http://old.nabble.com/-scala--CLI-library--ts19391923.html#a19391923) and\r\n[this thread](http://old.nabble.com/Parsing-command-lines-argument-in-a-%22scalaesque%22-way-tp26592006p26595257.html)\r\nwhich is available [as a gist](http://gist.github.com/246481) or [here](http://harnly.net/tmp/OptionsParser.scala).\r\n\r\nSonatype\r\n--------\r\n\r\n```scala\r\nlibraryDependencies += \"com.github.scopt\" %% \"scopt\" % \"2.1.0\"\r\n\r\nresolvers += \"sonatype-public\" at \"https://oss.sonatype.org/content/groups/public\"\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nscopt provides two flavors of parsers: immutable and mutable.\r\nEither case, first you need a case class that represents the configuration:\r\n\r\n```scala\r\ncase class Config(foo: Int = -1, bar: String = \"\", xyz: Boolean = false,\r\n  libname: String = \"\", libfile: String = \"\", maxlibname: String = \"\",\r\n  maxcount: Int = -1, whatnot: String = \"\")\r\n```\r\n\r\nAn immutable parser lets you pass around a config object as an argument into callback closures.\r\nOn the other hand, the mutable parsers are expected to modify a config object in place.\r\n\r\n### Immutable Parser\r\n\r\nHere's how you create a `scopt.immutable.OptionParser`.\r\n\r\n```scala\r\nval parser = new scopt.immutable.OptionParser[Config](\"scopt\", \"2.x\") { def options = Seq(\r\n  intOpt(\"f\", \"foo\", \"foo is an integer property\") { (v: Int, c: Config) => c.copy(foo = v) },\r\n  opt(\"o\", \"output\", \"output\") { (v: String, c: Config) => c.copy(bar = v) },\r\n  booleanOpt(\"xyz\", \"xyz is a boolean property\") { (v: Boolean, c: Config) => c.copy(xyz = v) },\r\n  keyValueOpt(\"l\", \"lib\", \"<libname>\", \"<filename>\", \"load library <libname>\")\r\n    { (key: String, value: String, c: Config) => c.copy(libname = key, libfile = value) },\r\n  keyIntValueOpt(None, \"max\", \"<libname>\", \"<max>\", \"maximum count for <libname>\")\r\n    { (key: String, value: Int, c: Config) => c.copy(maxlibname = key, maxcount = value) },\r\n  arg(\"<file>\", \"some argument\") { (v: String, c: Config) => c.copy(whatnot = v) }\r\n) }\r\n// parser.parse returns Option[C]\r\nparser.parse(args, Config()) map { config =>\r\n  // do stuff\r\n} getOrElse {\r\n  // arguments are bad, usage message will have been displayed\r\n}\r\n```\r\n\r\nThe above generates the following usage text:\r\n\r\n    Usage: scopt [options] <filename>\r\n    \r\n      -f <value> | --foo <value>\r\n            foo is an integer property\r\n      -o <file> | --output <file>\r\n            output is a string property\r\n      --xyz <value>\r\n            xyz is a boolean property\r\n      -l:<libname>=<filename> | --lib:<libname>=<filename>\r\n            load library <libname>\r\n      <singlefile>\r\n            <singlefile> is an argument\r\n\r\n### Mutable Parser\r\n\r\nCreate a `scopt.mutable.OptionParser` and customise it with the options you need, passing in functions to process each option or argument.\r\n\r\n```scala\r\nval parser = new scopt.mutable.OptionParser(\"scopt\", \"1.x\") {\r\n  intOpt(\"f\", \"foo\", \"foo is an integer property\", { v: Int => config.foo = v })\r\n  opt(\"o\", \"output\", \"<file>\", \"output is a string property\", { v: String => config.bar = v })\r\n  booleanOpt(\"xyz\", \"xyz is a boolean property\", { v: Boolean => config.xyz = v })\r\n  keyValueOpt(\"l\", \"lib\", \"<libname>\", \"<filename>\", \"load library <libname>\",\r\n    {(key: String, value: String) => { config.libname = key; config.libfile = value } })\r\n  arg(\"<singlefile>\", \"<singlefile> is an argument\", { v: String => config.whatnot = v })\r\n  // arglist(\"<file>...\", \"arglist allows variable number of arguments\",\r\n  //   { v: String => config.files = (v :: config.files).reverse })\r\n}\r\nif (parser.parse(args)) {\r\n  // do stuff\r\n}\r\nelse {\r\n  // arguments are bad, usage message will have been displayed\r\n}\r\n```\r\n\r\nBuilding\r\n--------\r\n\r\nsbt to build scopt.\r\n\r\nLicense\r\n-------\r\n\r\nMIT License.\r\n\r\nChanges\r\n-------\r\n\r\nSee [notes](https://github.com/scopt/scopt/tree/master/notes).\r\n","tagline":"simple scala command line options parsing","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}